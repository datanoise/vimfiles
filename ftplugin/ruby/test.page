
#  -------------Author--------------- 
#  `$author^ 



drdr.xp

drdr.xp


#  -------------dow--------------- 
#  downto(`lbound^) { |`arg^| `cursor^ } 



downto(0) { |i|  }

downto(lbound_TYPED) { |arg_TYPED|  }


#  -------------attr--------------- 
#  attr_`what^ :`attr^`...^, :`attr^`...^ 



attr_reader :, :, :

  attr_ :attr_TYPED_TYPED


#  -------------tc--------------- 
#  require "test/unit" 
#  require "`module^" 
#   
#  class Test`ClassName^ < Test::Unit:TestCase 
#    def test_`name^`(`args`)^ 
#      `block^ 
#    end` 
#   
#    `def...^ 
#  end 



require "test/unit"
require "module"

class TestModule < Test::Unit:TestCase
  def test_name(args)
    # block
  end

  def test_name(args)
    # block
  end

  def test_name(args)
    # block
  end
end

require "test/unit"
require "module_TYPED"

class TestClassNameTYPED < Test::Unit:TestCase
  def test_name_TYPED(args_TYPED)
    block_TYPED
  end

  def_TYPED
end


#  -------------grep--------------- 
#  grep(/`pattern^/) { |`match^| `cursor^ } 



grep(/pattern/) { |m|  }

grep(/pattern_TYPED/) { |match_TYPED|  }


#  -------------ass--------------- 
#  assert(`boolean condition^` `message...^) 



assert(boolean condition, _)

assert(booleancondition_TYPED message_TYPED)


#  -------------tas--------------- 
#  desc "`task description^" 
#  task :`task name^` `deps...^ do 
#  `cursor^ 
#  end 



desc "task description"
task :task_name=> [:task, :task, :task] do
  
end

desc "taskdescription_TYPED"
task :taskname_TYPED deps_TYPED do
  
end


#  -------------kv--------------- 
#  :`key^ => `value^`...^, :`keyn^ => `valuen^`...^ 



:key => value, :keyn => valuen, :keyn => valuen

:key_TYPED => value_TYPED_TYPED


#  -------------begin_--------------- 
#  begin 
#  `wrapped^` 
#  `rescue...^` 
#  `else...^` 
#  `ensure...^ 
#  end 


begin
  WRAPPED_TEXT
rescue Exception
  # block
rescue Exception
  # block
else
  # block
ensure
  
end

begin
  WRAPPED_TEXT
  rescue_TYPED
  else_TYPED
  ensure_TYPED
end



#  -------------det--------------- 
#  detect { |`obj^| `cursor^ } 



detect { |obj|  }

detect { |obj_TYPED|  }


#  -------------def--------------- 
#  def `method^`(`args`)^ 
#  `cursor^ 
#  end 



def method(args)
  
end

def method_TYPED(args_TYPED)
  
end


#  -------------Date--------------- 
#  `date()^ 



2009 May 10

2009 May 10


#  -------------bm--------------- 
#  TESTS = `times^10_000^ 
#   
#  Benchmark.bmbm do |result| 
#  `cursor^ 
#  end 



TESTS = 10_000

Benchmark.bmbm do |result|
  
end

TESTS = times_TYPED

Benchmark.bmbm do |result|
  
end


#  -------------any--------------- 
#  any? { |`element^| `cursor^ } 



any? { |element|  }

any? { |element_TYPED|  }


#  -------------map--------------- 
#  map { |`arg^| `cursor^ } 



map { |arg|  }

map { |arg_TYPED|  }


#  -------------tra--------------- 
#  transaction(`_^) { `cursor^ } 



transaction(true) {  }

transaction(__TYPED) {  }


#  -------------clstr--------------- 
#  `ClassName^ = Struct.new(:`attr^`...^, :`attrn^`...^) `do...^ 



ClassName = Struct.new(:attr, :attrn, :attrn) do
  
end

ClassNameTYPED = Struct.new(:attr_TYPED_TYPED) do_TYPED


#  -------------col--------------- 
#  collect { |`obj^| `cursor^ } 



collect { |obj|  }

collect { |obj_TYPED|  }


#  -------------Enum--------------- 
#  include Enumerable 
#   
#  def each(&block) 
#  `cursor^ 
#  end 



include Enumerable

def each(&block)
  
end

include Enumerable

def each(&block)
  
end


#  -------------gsub--------------- 
#  gsub(/`pattern^/) { |`match^| `cursor^ } 



gsub(/pattern/) { |m|  }

gsub(/pattern_TYPED/) { |match_TYPED|  }


#  -------------deec--------------- 
#  Marshal.load(Marshal.dump(`obj^)) 



Marshal.load(Marshal.dump(obj))

Marshal.load(Marshal.dump(obj_TYPED))


#  -------------tim--------------- 
#  times {` |`index`|^ `cursor^ } 



times { |index|  }

times { |index_TYPED|  }


#  -------------fdir--------------- 
#  File.dirname(`_^) 



File.dirname()

File.dirname(__TYPED)


#  -------------while--------------- 
#  while `boolean cond^ 
#  `cursor^ 
#  end 



while boolean cond
  
end

while booleancond_TYPED
  
end


#  -------------fread--------------- 
#  File.read('`filename^') 



File.read('filename')

File.read('filename_TYPED')


#  -------------ea--------------- 
#  each { |`e^| `cursor^ } 



each { |e|  }

each { |e_TYPED|  }


#  -------------ali--------------- 
#  alias :`new^ :`old^ 



alias :new :old_new

alias :new_TYPED :old_TYPED


#  -------------min--------------- 
#  min { |`element1^, `element2^| `cursor^ } 



min { |element1, element2|  }

min { |element1_TYPED, element2_TYPED|  }


#  -------------all--------------- 
#  all? { |`element^| `cursor^ } 



all? { |element|  }

all? { |element_TYPED|  }


#  -------------module_--------------- 
#  module `_^ 
#  `wrapped^ 
#  end 


module 
  WRAPPED_TEXT
end

module TYPED
  WRAPPED_TEXT
end



#  -------------invoke_--------------- 
#  `name^(`wrapped^) 


name(WRAPPED_TEXT)

name_TYPED(WRAPPED_TEXT)



#  -------------dirg--------------- 
#  Dir.glob('`dir^') { |`f^| `cursor^ } 



Dir.glob('dir') { |f|  }

Dir.glob('dir_TYPED') { |f_TYPED|  }


#  -------------max--------------- 
#  max { |`element1^, `element2^| `cursor^ } 



max { |element1, element2|  }

max { |element1_TYPED, element2_TYPED|  }


#  -------------zip--------------- 
#  zip(`enum^) { |`row^| `cursor^ } 



zip(enum) { |row|  }

zip(enum_TYPED) { |row_TYPED|  }


#  -------------open--------------- 
#  open("`filename^"` `mode...^) { |`io^| `cursor^ } 



open("filename", 'wb') { |io|  }

open("filename_TYPED" mode_TYPED) { |io_TYPED|  }


#  -------------scan--------------- 
#  scan(/`pattern^/) { |`match^| `cursor^ } 



scan(/pattern/) { |m|  }

scan(/pattern_TYPED/) { |match_TYPED|  }


#  -------------fin--------------- 
#  find { |`element^| `cursor^ } 



find { |element|  }

find { |element_TYPED|  }


#  -------------new--------------- 
#  `var^ = `Object^.new`(`args`)^ 



var = Object.new(args)

var_TYPED = ObjectTYPED.new(args_TYPED)


#  -------------fina--------------- 
#  find_all { |`element^| `cursor^ } 



find_all { |element|  }

find_all { |element_TYPED|  }


#  -------------tif--------------- 
#  (`boolean exp^) ? `exp if true^ : `exp if false^ 



(boolean exp) ? exp if true : exp if false

(booleanexp_TYPED) ? expiftrue_TYPED : expiffalse_TYPED


#  -------------rb--------------- 
#  #!/usr/bin/env ruby -w 



#!/usr/bin/env ruby -w
#
#!/usr/bin/env ruby -w
#

#  -------------begin--------------- 
#  begin 
#    `expr^` 
#  `rescue...^` 
#  `else...^` 
#  `ensure...^ 
#  end 



begin
  expr
rescue Exception
  # block
rescue Exception
  # block
else
  # block
ensure
  
end

begin
  expr_TYPED
  rescue_TYPED
  else_TYPED
  ensure_TYPED
end


#  -------------sub--------------- 
#  sub(/`pattern^/) { |`match^| `cursor^ } 



sub(/pattern/) { |m|  }

sub(/pattern_TYPED/) { |match_TYPED|  }


#  -------------sorb--------------- 
#  sort_by {` |`arg`|^ `cursor^ } 



sort_by { |arg|  }

sort_by { |arg_TYPED|  }


#  -------------lit--------------- 
#  %`_^[`content^] 



%w[]

%__TYPED[content_TYPED]


#  -------------xml--------------- 
#  REXML::Document.new(File.read("`filename^")) 



REXML::Document.new(File.read("filename"))

REXML::Document.new(File.read("filename_TYPED"))


#  -------------defds--------------- 
#  def_delegators :`del obj^, :`del methods^ 



def_delegators :del obj, :del methods

def_delegators :delobj_TYPED, :delmethods_TYPED


#  -------------Forw--------------- 
#  extend Forwardable 



extend Forwardable

extend Forwardable


#  -------------y--------------- 
#  :yields: 



y

y


#  -------------reve--------------- 
#  reverse_each { |`element^| `cursor^ } 



reverse_each { |element|  }

reverse_each { |element_TYPED|  }


#  -------------cl--------------- 
#  class `ClassName^ 
#  `cursor^ 
#  end 



class ClassName
  
end

class ClassNameTYPED
  
end


#  -------------Yd--------------- 
#  File.open("`filename^.yaml", "wb") { |`file^| YAML.dump(`obj^,`file^) } 



File.open("filename.yaml", "wb") { |file| YAML.dump(obj,file) }

File.open("filename_TYPED.yaml", "wb") { |file_TYPED| YAML.dump(obj_TYPED,file_TYPED) }


#  -------------rep--------------- 
#  result.report("`name^: ") { TESTS.times { `cursor^ } } 



result.report("name: ") { TESTS.times {  } }

result.report("name_TYPED: ") { TESTS.times {  } }


#  -------------Email--------------- 
#  `$email^ 



bal@bla

bal@bla


#  -------------END--------------- 
#  END { 
#  `cursor^ 
#  } 



END {
  
}

END {
  
}


#  -------------Yl--------------- 
#  File.open("`filename^.yaml") { |`file^| YAML.load(`file^) } 



File.open("filename.yaml") { |file| YAML.load(file) }

File.open("filename_TYPED.yaml") { |file_TYPED| YAML.load(file_TYPED) }


#  -------------loop--------------- 
#  loop do 
#  `cursor^ 
#  end 



loop do
  
end

loop do
  
end


#  -------------reqs--------------- 
#  %w[`libs^].map { |lib| require lib } 



%w[libs].map { |lib| require lib }

%w[libs_TYPED].map { |lib| require lib }


#  -------------file--------------- 
#  File.foreach('`filename^') { |`line^| `cursor^ } 



File.foreach('filename') { |line|  }

File.foreach('filename_TYPED') { |line_TYPED|  }


#  -------------subcl--------------- 
#  class `ClassName^ < `Parent^ 
#  `cursor^ 
#  end 



class ClassName < Parent
  
end

class ClassNameTYPED < ParentTYPED
  
end


#  -------------defd--------------- 
#  def_delegator :`del obj^, :`del meth^, :`new name^ 



def_delegator :del obj, :del meth, :new name

def_delegator :delobj_TYPED, :delmeth_TYPED, :newname_TYPED


#  -------------mod--------------- 
#  module `module name^ 
#  `cursor^ 
#  end 



module ModuleName
  
end

module ModulenameTYPED
  
end


#  -------------defi--------------- 
#  def initialize`(`args`)^ 
#  `cursor^ 
#  end 



def initialize(args)
  
end

def initialize(args_TYPED)
  
end


#  -------------upt--------------- 
#  upto(`ubound^) { |`arg^| `cursor^ } 



upto(10) { |i|  }

upto(ubound_TYPED) { |arg_TYPED|  }


#  -------------array--------------- 
#  Array.new(`size^) { |`arg^| `cursor^ } 



Array.new(5) { |i|  }

Array.new(size_TYPED) { |arg_TYPED|  }


#  -------------ea_--------------- 
#  each_`what^|`_^| `cursor^ } 



each_what {|var|  }

each_what_TYPED {|var_TYPED|  }


#  -------------Comp--------------- 
#  include Comparable 
#   
#  def <=>(other) 
#  `cursor^ 
#  end 



include Comparable

def <=>(other)
  
end

include Comparable

def <=>(other)
  
end


#  -------------nam--------------- 
#  namespace :`ns^ do 
#  `cursor^ 
#  end 



namespace :test do
  
end

namespace :ns_TYPED do
  
end


#  -------------cfy--------------- 
#  classify { |`element^| `cursor^ } 



classify { |element|  }

classify { |element_TYPED|  }


#  -------------deft--------------- 
#  def test_`name^`(`args`)^ 
#  `cursor^ 
#  end 



def test_name(args)
  
end

def test_name_TYPED(args_TYPED)
  
end


#  -------------ste--------------- 
#  step(`count^` `step...^) { |`arg^| `cursor^ } 



step(10, 2) { |i|  }

step(count_TYPED step_TYPED) { |arg_TYPED|  }


#  -------------amm--------------- 
#  alias_method :`new^, :`old^ 



alias_method :new, :old_new

alias_method :new_TYPED, :old_TYPED


#  -------------usau--------------- 
#  unless ARGV`_^ 
#    abort "Usage: #{$PROGRAM_NAME} `args^" 
#  end 



unless ARGV
  abort "Usage: #{$PROGRAM_NAME} [options]"
end

unless ARGV__TYPED
  abort "Usage: #{$PROGRAM_NAME} args_TYPED"
end


#  -------------BEG--------------- 
#  BEGIN { 
#  `cursor^ 
#  } 



BEGIN {
  
}

BEGIN {
  
}


#  -------------pathf--------------- 
#  File.join(File.dirname(__FILE__), "`path^") 



File.join(File.dirname(__FILE__), "../lib")

File.join(File.dirname(__FILE__), "path_TYPED")


#  -------------wid--------------- 
#  with_index { |`element^, `index^| `cursor^ } 



with_index { |element, i|  }

with_index { |element_TYPED, index_TYPED|  }


#  -------------until--------------- 
#  until `boolean cond^ 
#  `cursor^ 
#  end 



until boolean cond
  
end

until booleancond_TYPED
  
end


#  -------------case--------------- 
#  case `target^` 
#  `when...^` 
#  `else...^ 
#  end 



case target
when comparison

when comparison

else

end

case target_TYPED
  when_TYPED
  else_TYPED
end


#  -------------ass_--------------- 
#  assert_`what^`_^ 



assert_)

assert___TYPED


#  -------------sor--------------- 
#  sort { |`element1^, `element2^| `element1^ <=> `element2^ } 



sort { |element1, element2| element1 <=> element2 }

sort { |element1_TYPED, element2_TYPED| element1_TYPED <=> element2_TYPED }


#  -------------par--------------- 
#  partition { |`element^| `cursor^ } 



partition { |element|  }

partition { |element_TYPED|  }


#  -------------sel--------------- 
#  select { |`element^| `cursor^ } 



select { |element|  }

select { |element_TYPED|  }


#  -------------fet--------------- 
#  fetch(`name^) { |`key^| `cursor^ } 



fetch(name) { |key|  }

fetch(name_TYPED) { |key_TYPED|  }


#  -------------Md--------------- 
#  File.open("`filename^", "wb") { |`file^| Marshal.dump(`obj^, `file^) } 



File.open("filename", "wb") { |file| Marshal.dump(obj, file) }

File.open("filename_TYPED", "wb") { |file_TYPED| Marshal.dump(obj_TYPED, file_TYPED) }


#  -------------hash--------------- 
#  Hash.new { |`hash^,`key^| `hash^[`key^] = `cursor^ } 



Hash.new { |h,k| h[k] =  }

Hash.new { |hash_TYPED,key_TYPED| hash_TYPED[key_TYPED] =  }


#  -------------modf--------------- 
#  module `module name^ 
#    module_function 
#   
#    `cursor^ 
#  end 



module ModuleName
  module_function

  
end

module ModulenameTYPED
  module_function

  
end


#  -------------defs--------------- 
#  def self.`method^`(`args`)^ 
#  `cursor^ 
#  end 



def self.method(args)
  
end

def self.method_TYPED(args_TYPED)
  
end


#  -------------Ml--------------- 
#  File.open("`filename^", "rb") { |`file^| Marshal.load(`file^) } 



File.open("filename", "rb") { |file| Marshal.load(file) }

File.open("filename_TYPED", "rb") { |file_TYPED| Marshal.load(file_TYPED) }


#  -------------inj--------------- 
#  inject`(`arg`)^ { |`accumulator^, `element^| `cursor^ } 



inject(arg) { |acc, el|  }

inject(arg_TYPED) { |accumulator_TYPED, element_TYPED|  }


#  -------------unif--------------- 
#  ARGF.each_line do |`line^| 
#  `cursor^ 
#  end 



ARGF.each_line do |line|
  
end

ARGF.each_line do |line_TYPED|
  
end


#  -------------dir--------------- 
#  Dir[`_^] 



Dir[/**/*]

Dir[__TYPED]


#  -------------def_--------------- 
#  def `_^`(`args`)^ 
#  `wrapped^ 
#  end 


def _(args)
  WRAPPED_TEXT
end

def __TYPED(args_TYPED)
  WRAPPED_TEXT
end



#  -------------app--------------- 
#  if __FILE__ == $PROGRAM_NAME 
#  `cursor^ 
#  end 



if __FILE__ == $PROGRAM_NAME
  
end

if __FILE__ == $PROGRAM_NAME
  
end


#  -------------int--------------- 
#  #{`_^} 



#{}
#
#{__TYPED}
#

#  -------------rdoc--------------- 
#  =begin rdoc 
#  #`cursor^ 
#  #=end 



rdoc

rdoc


#  -------------fjoin--------------- 
#  File.join(`dir^, `path^) 



File.join(dir, path)

File.join(dir_TYPED, path_TYPED)


#  -------------_d--------------- 
#  __DATA__ 



__DATA__

__DATA__


#  -------------_e--------------- 
#  __END__ 



__END__

__END__


#  -------------_f--------------- 
#  __FILE__ 



__FILE__

__FILE__


#  -------------do--------------- 
#  do` |`args`|^ 
#  `cursor^ 
#  end 



do |args|
  
end

do |args_TYPED|
  
end


#  -------------rej--------------- 
#  reject { |`element^| `cursor^ } 



reject { |element|  }

reject { |element_TYPED|  }


#  -------------class_--------------- 
#  class `_^ 
#  `wrapped^ 
#  end 


class 
  WRAPPED_TEXT
end

class TYPED
  WRAPPED_TEXT
end



#  -------------sinc--------------- 
#  class << self; self; end 



class << self; self; end

class << self; self; end


#  -------------usai--------------- 
#  if ARGV`_^ 
#    abort "Usage: #{$PROGRAM_NAME} `args^" 
#  end 



if ARGV
  abort "Usage: #{$PROGRAM_NAME} [options]"
end

if ARGV__TYPED
  abort "Usage: #{$PROGRAM_NAME} args_TYPED"
end


#  -------------cld--------------- 
#  class `ClassName^ < DelegateClass(`ParentClass^) 
#    def initialize`(`args`)^ 
#      super(`delegate object^) 
#   
#      `cursor^ 
#    end 
#  end 



class ClassName < DelegateClass(ParentClass)
  def initialize(args)
    super(delegate object)

    
  end
end

class ClassNameTYPED < DelegateClass(ParentClassTYPED)
  def initialize(args_TYPED)
    super(delegateobject_TYPED)

    
  end
end


#  -------------req--------------- 
#  require '`lib^' 



require 'lib'

require 'lib_TYPED'


#  -------------unless--------------- 
#  unless `boolean cond^ 
#  `cursor^ 
#  end 



unless boolean cond
  
end

unless booleancond_TYPED
  
end


#  -------------File--------------- 
#  `file()^ 



test.page

test.page


#  -------------if--------------- 
#  if `boolean exp^ 
#    `block^` 
#  `elsif...^` 
#  `else...^ 
#  end 



if boolean exp
  # block
elsif boolean exp
  # block
elsif boolean exp
  # block
else
  
end

if booleanexp_TYPED
  block_TYPED
  elsif_TYPED
  else_TYPED
end


#  -------------deli--------------- 
#  delete_if { |`arg^| `cursor^ } 



delete_if { |arg|  }

delete_if { |arg_TYPED|  }


#  -------------defmm--------------- 
#  def method_missing(meth, *args, &block) 
#  `cursor^ 
#  end 



def method_missing(meth, *args, &block)
  
end

def method_missing(meth, *args, &block)
  
end


#  -------------cls--------------- 
#  class << `self^ 
#  `cursor^ 
#  end 



class << self
  
end

class << self_TYPED
  
end


#  -------------lam--------------- 
#  lambda {` |`args`|^ `cursor^ } 



lambda { |args|  }

lambda { |args_TYPED|  }


#  -------------Pn--------------- 
#  PStore.new("`filename^") 



PStore.new("filename")

PStore.new("filename_TYPED")

