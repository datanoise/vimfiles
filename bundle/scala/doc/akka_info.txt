*akkainfo.txt*	       Akka Reference and Information	        Feb 21, 2011

Author:    Derek Wyatt <derek@{my first name}{my last name}.org>

Copyright: (c) 2011 by Derek Wyatt
           No license implied... use it for whatever tickles your particular
           fancy.

==============================================================================
0. Contents                                              *akka* *akka-contents*
------------------------------------------------------------------------------

  1. Actors..................................: |akka-actors|
    1.1 Actor Lifecycle......................: |akka-actor-lifecycle|
    1.2 Actor Companion Object...............: |akka-actor-object|
    1.3 Defining by Derivation...............: |akka-actor-derive|
    1.4 Anonymous Creation...................: |akka-actor-anonymous|
    1.5 Actor vs. ActorRef...................: |akka-actor-actorref|
    1.6 !, !!, and !!!.......................: |akka-actor-send-message|
      1.6.1 !................................: |akka-actor-!|
      1.6.2 !!...............................: |akka-actor-!!|
      1.6.3 !!!..............................: |akka-actor-!!!|
      1.6.4 Unifying Pattern.................: |akka-actor-unifying-msg|
    1.7 Actor Control........................: |akka-actor-control|
      1.7.1 Starting and Stopping............: |akka-actor-start-stop|
      1.7.2 Poison Pill......................: |akka-actor-poisonpill|
      1.7.3 Actor Murder.....................: |akka-actor-murder|
    1.8 Hot-Swapping.........................: |akka-actor-hotswap|
      1.8.1 Invoking the Hot-Swap............: |akka-actor-invoke-hotswap|
      1.8.2 Reverting the Hot-Swap...........: |akka-actor-revert-hotswap|
    1.9 PartialFunction Chaining.............: |akka-actor-partialfunc-chaining|
    1.10 Actor Registry......................: |akka-actor-registry|
    1.11 Remote Actors.......................: |akka-actor-remote|
      1.11.1 Starting Up Remote..............: |akka-actor-remote-startup|
      1.11.2 Registering Actors..............: |akka-actor-remote-register|
      1.11.3 Invoking Actors Remotely........: |akka-actor-remote-invoke|
      1.11.4 Connection Fault Tolerance......: |akka-actor-remote-resilience|
      1.11.5 Remote Security.................: |akka-actor-remote-security|
      1.11.6 Session Based Servers...........: |akka-actor-remote-sessions|
      1.11.7 Event Listening.................: |akka-actor-remote-events|
      1.11.8 Messge Serialization............: |akka-actor-remote-serialization|
  2. Actor Supervision.......................: |akka-supervision|
  3. Actor Routing...........................: |akka-routing|
    3.1 Simple Dispatching...................: |akka-routing-dispatching|
    3.2 Simple Load Balancing................: |akka-routing-loadbalance|
    3.3 Actor Pools..........................: |akka-routing-pools|


==============================================================================
1. Actors                                                   *akka-actors* {{{1
------------------------------------------------------------------------------

1.1 Actor Lifecycle                                *akka-actor-lifecycle* {{{2
------------------------------------------------------------------------------

NEW (newly created actor) - can't receive messages (yet)
    => STARTED (when 'start' is invoked) - can receive messages
        => SHUT DOWN (when 'exit' or 'stop' is invoked) - can't do anything


1.2 Actor Companion Object                            *akka-actor-object* {{{2
------------------------------------------------------------------------------

The {Actor} object provides some convenience methods for constructing some
"stuff":

actorOf(factory => Actor): ActorRef                      *akka-actor-actorOf1*
    Creates an ActorRef out of the Actor. Allows you to pass in a factory
    function that creates the Actor. Please note that this function can be
    invoked multiple times if for example the Actor is supervised and needs to
    be restarted.

    This function should NOT be used for remote actors.
!sc!
        import Actor._
        val actor = actorOf(new MyActor)
        actor.start
        actor ! message
        actor.stop
!/sc!
    You can create and start the actor in one statement like this:
!sc!
        val actor = actorOf(new MyActor).start!/sc!

actorOf(clazz: Class[_ <: akka.actor.Actor]): ActorRef   *akka-actor-actorOf2*
    Creates an ActorRef out of the Actor of the specified Class.
!sc!
        import Actor._
        val actor = actorOf(classOf[MyActor])
        actor.start
        actor ! message
        actor.stop
!/sc!
    You can create and start the actor in one statement like this:
!sc!
        val actor = actorOf(classOf[MyActor]).start!/sc!

                                                        *akka-actor-actorOf3*
actorOf[T <: Actor](implicit arg0: Manifest[T]): ActorRef
    Creates an ActorRef out of the Actor with type T.
!sc!
        import Actor._
        val actor = actorOf[MyActor]
        actor.start
        actor ! message
        actor.stop
!/sc!
    You can create and start the actor in one statement like this:
!sc!
        val actor = actorOf[MyActor].start!/sc!

{val} log : Logger                                          *akka-actor-log*
    This is merely a {val} which will will return the contextual SLF4J logger.

{val} registry : ActorRegistry                   *akka-actor-registry-short*
    This value contains the current {ActorRegistry} against which we can
    register and lookup different {Actor}s.  I can't find the code for this at
    the moment, so I'm not sure if it's actually {Actor}s or {ActorRef}s -
    probably the latter.

{lazy} {val} remote : RemoteSupport                *akka-actor-remote-short*
    Provides access to the remoting system support for launching and accessing
    remote {Actor}s

                                                          *akka-actor-spawn*
spawn(body: => Unit)(implicit dispatcher: MessageDispatcher = ...) : Unit
    Use to spawn out a block of code in an event-driven actor. Will shut actor
    down when the block has been executed.

    NOTE: If used from within an Actor then has to be qualified with
    {Actor.spawn} since there is a method {spawn[ActorType]} in the Actor
    trait already. Example:
!sc!
        import Actor.{spawn}
        spawn {
            ... // do stuff
        }
!/sc!
1.3 Defining by Derivation                            *akka-actor-derive* {{{2
------------------------------------------------------------------------------
!sc!
    scala> import akka.actor._
    scala> import akka.actor.Actor._ 
    scala> class MyActor extends Actor {
         |   def receive = {
         |     case "hithere" =>
         |       println("Well, hello there")
         |   }
         | } 
    defined class MyActor

    scala> var a = actorOf[MyActor].start
    
    scala> a ! "hithere"
    Well, hello there
    
    scala> a.stop 
!/sc!

1.4 Anonymous Creation                             *akka-actor-anonymous* {{{2
------------------------------------------------------------------------------
!sc!
    scala> var a = actorOf(new Actor {
         |                   def receive = {
         |                     case "bite me" => println("NO!  Bite _ME_!")
         |                   }
         |                 })
    a: akka.actor.ActorRef = Actor[$anonfun$1$$anon$1:8c65a3d0-4379-11e0-9c39-005056c00008]

    scala> a ! "bite me"
    NO!  Bite _ME_!

    scala> a.stop
!/sc!

1.5 Actor vs. ActorRef                              *akka-actor-actorref* {{{2
------------------------------------------------------------------------------

One derives from {Actor} but the meat of things happens in the {ActorRef}, due
to the fact (I assume at this point) that the {ActorRef} provides the
mechanisms behind |akka-hotswap| and |akka-fault-tolerance|.  By divorcing the
implementation from the invocation, Akka can provide more execution framework
aspects that you no longer need to worry about.

The {actorOf} factory method available on the |akka-actor-object| provides the
ability to get an {ActorRef} from a derivation of {Actor}.

The {Actor} trait itself has very little in it and is really only there to
give us a few points of extension:

receive()

    The point of entry for incoming messages - this is the
    message handler that gets called when someone makes a
    call to:
        - ! (|akka-actor-!|)
        - !! (|akka-actor-!!|)
        - !!! (|akka-actor-!!!|)

preStart()

    Called before {Actor.start} (or {ActorRef.start}) is
    called.  Used to setup stuff before the /first/ call.

postStop()

    Called before the {Actor} is stopped.  This can happen
    in a few different ways so it's not specifically called
    before a call to {Actor.stop}.

preRestart()

    Called before the {Actor} is restarted.  When a supervisor
    restarts the Actor, it will first call this method to
    allow it to clear up some state first.

postRestart()

    Called after the {Actor} is restarted.  This might let you
    get something going again after the core system is up and
    running.

If you need access to the stuff held in the {self} field, you can import the
members directly, if you want:
!sc!
    class MyActor extends Actor {
      import self._
      id = ...
      dispatcher = ...
      start
      ...
    }
!/sc!

1.6 !, !!, and !!!                              *akka-actor-send-message* {{{2
------------------------------------------------------------------------------

Actors are all about passing messages around and the !, !! and !!! methods are
the {Actor}'s mechanisms for passing messages.

1.6.1 !                                                    *akka-actor-!* {{{3
------------------------------------------------------------------------------

The simple ! message is the best way to send something - it's the one-way
fire-and-forget message that demands full asynchrony.  Obviously if you only
need a one-way message with no confirmation of delivery, you're fine just
sending it any never thinking about it again.  If, on the other hand, this
one-way message is actually part of a multi-message conversation, you need to
have some way of getting things back.

The most reliable way of doing this to demand an {ActorRef} as a parameter on
the message.
!sc!
    scala> case class GreetRequest(greeting: String, replyTo: ActorRef)
    defined class GreetRequest

    scala> case class GreetResponse(greeting: String)                                       
    defined class GreetResponse

    scala> class ServerActor extends Actor {                           
         |   def receive = {
         |     case GreetRequest(greeting, replyTo) =>
         |       replyTo ! GreetResponse("You said, '" + greeting +
         |                               "', and I say 'Thanks'")
         |   }
         | }

    scala> class ClientActor extends Actor {
         |   def receive = {
         |     case GreetResponse(greeting) =>
         |       println(greeting)
         |   }
         | }
    defined class ClientActor
    
    scala> var server = actorOf[ServerActor].start
    server: akka.actor.ActorRef = Actor[ServerActor:2d95a200-4384-11e0-9c39-005056c00008]
    
    scala> var client = actorOf[ClientActor].start
    client: akka.actor.ActorRef = Actor[ClientActor:34f5c160-4384-11e0-9c39-005056c00008]
    
    scala> server ! GreetRequest("Hithere, ServerActor", client)
    You said, 'Hithere, ServerActor', and I say 'Thanks'

    scala> client.stop

    scala> server.stop
!/sc!
You could also do this by using the {implicit} {sender}, contained inside the
{self.sender} field, but you always have to be wary of whether or not the
object that sent the message was actually an {Actor} or not.  The type of the
{self.sender} is {Option[AnyRef]}, which allows for the notion that the
{sender} is not an {Actor}.  So you have to keep checking it, and if your code
would always like to see one there, then it's easiest to simply force it in
the message and then it's there all the time.


1.6.2 !!                                                  *akka-actor-!!* {{{3
------------------------------------------------------------------------------

The !! method is a blocking call.  The implication is that the reciever is
going to use the {self.reply} method in order to send a result to the caller.
The caller is going to wait on a {Future} explicitly and get back an
{Option[Any]} object in return.  If the call did not time out then the
{Option} will be a {Some} that actually contains the result and {None}
otherwise.

There are a couple of things to note here:

- Blocking is bad...
- ... but so is not getting a result and not knowing that

The virtue of the !! method is that you'll know if something timed out.  If,
on the other hand you use the ! method and expect to be called back later, you
need some mechanism to ensure that you are actually called back.  Nobody's
going to tell you something timed out because the timing out is part of the
business logic, not the framework.

NOTE: I'm expecting Akka to help out here.  The fault tolerance in the system
based on {Supervisor}s should be able to buy us - not necessarily guaranteed
delivery - enough information in the system that lets us know when something
croaked while still maintaining fully asynchrony.
!sc!
    scala> case class SyncGreetRequest(greeting: String)
    defined class SyncGreetRequest
    
    scala> class SyncServerActor extends Actor {        
         |   def receive = {                            
         |     case SyncGreetRequest(greeting) =>       
         |       self.reply("You said, '" + greeting + "', and I say 'Thanks'")
         |   }
         | }
    defined class SyncServerActor
    
    scala> case class Go(server: ActorRef)
    defined class Go
    
    scala> class SyncClientActor extends Actor {                                    
         |   def receive = {                                                        
         |     case Go(server) =>                                                   
         |       println((server !! SyncGreetRequest("Hithere, SyncServerActor")).get)
         |   }
         | }
    defined class SyncClientActor
    
    scala> var client = actorOf[SyncClientActor].start
    client: akka.actor.ActorRef = Actor[SyncClientActor:28fb2af0-4387-11e0-9c39-005056c00008]
    
    scala> client ! Go(server) 
    You said, 'Hithere, SyncServerActor', and I say 'Thanks'
!/sc!
Note above that I simply call {get} on the {Option[Any]} I receive simply
because it's easy, but we have to remember that it is an {Option} object, so
it may not be valid to do that.


1.6.3 !!!                                                *akka-actor-!!!* {{{3
------------------------------------------------------------------------------

The !!! method returns a {Future}.  This is a non-blocking call but requires
the management of the {Future} and possibly turns things into a degenerate
polling mechanism as a result.

There is a plus side here, though... the caller that receives the {Future}
need not be an {Actor}, as is the case in the !! call.  Using the exact same
{SyncServerActor} defined above, we have:
!sc!
    scala> val future = server !!! SyncGreetRequest("Hithere, SyncServerActor")
    future: akka.dispatch.Future[Nothing] =
      akka.dispatch.DefaultCompletableFuture@bf3fd22
    
    scala> future.result
    res16: Option[Nothing] =
      Some(You said, 'Hithere, SyncServerActor', and I say 'Thanks')
!/sc!

1.6.4 Unifying Pattern                          *akka-actor-unifying-msg* {{{3
------------------------------------------------------------------------------

Ideally we should be able to unify the !, !!, !!! usage into a single pattern,
where the client can choose to do a request / response interaction via the
"scalable" ! or by the "deterministic" !!, or !!!.  This is a non-general
pattern that can use some work to generalize a bit more with some generics:
!sc!
  import akka.actor._
  import akka.actor.Actor._
  
  case class Request(msg: String, replyTo: ActorRef = null)
  case class Response(msg: String)
  case class SendRequestTo(msg: String, actor: ActorRef)
  
  class Server extends Actor {
    def receive = {
      case Request(msg, replyTo) =>
        if (replyTo == null)
          self.reply(msg + " : dood")
        else
          replyTo ! Response(msg + " : dood")
    }
  }
  
  class Client extends Actor {
    def receive = {
      case Response(msg) =>
        println("Client got -> " + msg)
      case SendRequestTo(msg, actor) =>
        actor ! Request(msg, self)
    }
  }
  
  scala> val server = actorOf[Server].start
  scala> val client = actorOf[Client].start

  scala> server !! Request("Waiting on Future")
  res0: Option[Nothing] = Some(Waiting on a future : dood)
 
  scala> val future = server !!! Request("Getting back a Future")
  scala> future.result
  res1: Option[Nothing] = Some(Getting back a Future : dood)
 
  scala> client ! SendRequestTo("Hithere", server)
  Client got -> Hithere : dood
!/sc!

1.6.5 Forwarding a Future                         *akka-actor-future-fwd* {{{3
------------------------------------------------------------------------------

There are times when we may want to synchronize an asynchronous call.
i.e. something like this:
                                              +---> SomeOtherActor ! AsyncReq
                                              |
 [Client] SomeActor !!! Msg -> [SomeActor] <-->
                                              |
                                              +<--- AsyncRsp ! SomeActor

Or, in words...

  - [Client] wants to send !! or !!! to [SomeActor] for {Msg}

  - [SomeActor] could furnish that request, but unfortunately it's using
    [SomeOtherActor] and the only mechanism it has with [SomeOtherActor] is an
    asynchronous one.

  - We need some way to give results to the {Future} object held by [Client]
    over an asynchronous bridge.

We can do that with the following:
!sc!
    class SomeOtherActor extends Actor {
      def receive = {
        // Inherently asynchronous
        case AsyncReq =>
          self.sender.get ! AsyncRsp("Here's some results")
      }
    }

    class SomeActor extends Actor {
      val server = actorOf[SomeOtherActor].start
      def receive = {
        // The Client wants this to be Future-based
        case GetSomethingForMe =>
          // - Delegate the "senderFuture" to this temporary Actor.
          // - Create a closure, holding the future object for later use.
          // - Call the "server" and send the intended request and receive that
          //   one message.
          // - Once it's received, complete the future with the results and
          //   terminate yourself
          actorOf(new { val future = self.senderFuture.get } with Actor {
              def receive = {
                case AsyncRsp(results) =>
                  future.completeWithResult(results)
                  self.stop
                // It's very important to do this.  I previously had the call
                // to "server ! AsyncReq" in the constructor of this anonymous
                // Actor but that causes a race condition.  The call back to
                // this Actor's AsyncRsp(results) handler is called before the
                // 'start' call below completes.  Making the call in this
                // handler ensures that the Actor has been successfully
                // started
                case "go" =>
                  server ! AsyncReq
              }
            }).start ! "go"
      }
      override def postStop = { server.stop }
    }

    scala> val future = SomeActor !!! GetSomethingForMe
    scala> future.await
    scala> future.result.get
    res1: String = Here's some results
!/sc!

1.7 Actor Control                                    *akka-actor-control* {{{2
------------------------------------------------------------------------------

{Actor}s can be started easily enough and, in fact /must/ be started before
you can do anything with them.  If you try to send a message to an {Actor}
that has not been started then you're going to get yourself a big fat
{akka.actor.ActorInitializationException}.

1.7.1 Starting and Stopping                       *akka-actor-start-stop* {{{3
------------------------------------------------------------------------------

Both {Actor} and {ActorRef} have a {start} method on them.
!sc!
    scala> var a = actorOf(new Actor { def receive => } })
    a: akka.actor.ActorRef =
     Actor[$anonfun$1$$anon$1:3f434870-439f-11e0-8888-005056c00008]

    scala> a.start

    20:00:49.721 [main] DEBUG
      a.d.Dispatchers$globalExecutorBasedEventDrivenDispatcher$ -
      Starting up
      Dispatchers$globalExecutorBasedEventDrivenDispatcher$[
        akka:event-driven:dispatcher:global]
      with throughput [5]
    res2: akka.actor.ActorRef =
      Actor[$anonfun$1$$anon$1:3f434870-439f-11e0-8888-005056c00008]

    scala> a.stop

    20:02:17.924 [main] INFO  akka.actor.Scheduler$ - Starting up Scheduler
    20:02:18.935 [akka:scheduler-0]
      DEBUG a.d.Dispatchers$globalExecutorBasedEventDrivenDispatcher$ -
      Shutting down Dispatchers$globalExecutorBasedEventDrivenDispatcher$[
        akka:event-driven:dispatcher:global]
!/sc!

Note: You can't start an {Actor} that's already been stopped.

There's another way to shut down {Actor}s using the |akka-actor-registry|:
!sc!
    scala> a.start

    scala> Actor.registry.shutdownAll
    20:05:04.055 [main] INFO  akka.actor.ActorRegistry - Shutting down
      all actors in the system...
    20:05:04.063 [main] DEBUG akka.util.ReflectiveAccess$ - Could not
      get object [akka.actor.TypedActor$]
    20:05:04.119 [main] DEBUG akka.util.ReflectiveAccess$ - getObjectFor
    java.lang.ClassNotFoundException: akka.actor.TypedActor$
	at java.net.URLClassLoader$1.run(URLClassLoader.java:202) ~[na:1.6.0_22]
          . . .
    20:05:04.157 [main] INFO  akka.actor.ActorRegistry - All actors have been
      shut down and unregistered from ActorRegistry

    scala> a.isRunning
    res7: Boolean = false
!/sc!
Note the exception.  I'm not sure exactly why that's happened but I definitely
don't have an {TypedActor}s running, so it may be trying to do some sort of
Class Loader nonsense without checking for them first.  The bottom line
appears to be that the one {Actor} I had running is definitely stopped.


1.7.2 Poison Pill                                 *akka-actor-poisonpill* {{{3
------------------------------------------------------------------------------

Another way to kill an {Actor} off is to send it a {PoisonPill}:
!sc!
    scala> a.start
    res9: akka.actor.ActorRef =
      Actor[$anonfun$1$$anon$1:1330b630-43a1-11e0-8888-005056c00008]

    scala> a ! PoisonPill
    { ... shutdown messages here ... }
!/sc!

1.7.3 Actor Murder                                    *akka-actor-murder* {{{3
------------------------------------------------------------------------------

This was meant to hold the {Kill} message, but it looks like it's an old API
that's been removed in 1.0.  {Kill} meant that the {Actor} should toss its
cookies and the {Supervisor} should restart it, so "Kill" was a pretty silly
name considering it didn't actually die.

It looks like this has been replaced with {Restart} and {Exit} but I'm not
sure why there are two of these... they both seem to do the same thing.

	*Todo	investigate this more by doing some experiments with the callbacks


1.8 Hot-Swapping                                     *akka-actor-hotswap* {{{2
------------------------------------------------------------------------------

Hot-swapping allows the application to swap in new {Actor} message loops at
runtime.  What you're doing is replacing the {PartialFunction[Any,Unit]}
function that is normally created statically by defining the {receive}
function.  There are two ways you can do it:


1.8.1 Invoking the Hot-Swap                   *akka-actor-invoke-hotswap* {{{3
------------------------------------------------------------------------------

- Send a "HotSwap" message to the {Actor}
- Invoke the {become} method from within the {Actor}

The hot-swapped code is kept on a {Stack} so that it can be pushed and popped.
To hot-swap the {Actor} body using the "HotSwap" message:
!sc!
    actor ! HotSwap(self => {
      case message => self.reply("hot-swapped body")
    })
!/sc!
To hot-swap the {Actor} using {become}:
!sc!
    def angry: Receive = {
      case "foo" => self reply "I am already angry!!!"
      case "bar" => become(happy)
    }
     
    def happy: Receive = {
      case "bar" => self reply "I am already happy :-)"
      case "foo" => become(angry)
    }
     
    def receive = {
      case "foo" => become(angry)
      case "bar" => become(happy)
    }
!/sc!
A decent use of hot-swapping is to implement a finite state machine.  Here's
an example of using hot-swapping:
!sc!
    case object Swap
    class Swapper extends Actor {
     def receive = {
       case Swap =>
         println("Hi")
         become {
           case Swap =>
             println("Ho")
             unbecome // resets the latest 'become' (just for fun)
         }
      }
    }
     
    val swap = actorOf[Swapper].start
     
    swap ! Swap // prints Hi
    swap ! Swap // prints Ho
    swap ! Swap // prints Hi
    swap ! Swap // prints Ho
    swap ! Swap // prints Hi
    swap ! Swap // prints Ho
!/sc!

1.8.2 Reverting the Hot-Swap                  *akka-actor-revert-hotswap* {{{3
------------------------------------------------------------------------------

Because the implementations are shoved on a {Stack}, you can also revert them.
You do this by doing the opposite of what you did before:

- Send a "RevertHotSwap" message to the {Actor}
- Invoke the {unbecome} method from within the {Actor}

To do it with the {RevertHotSwap} message:
!sc!
    actor ! RevertHotSwap
!/sc!
and to do it with the {unbecome} method:
!sc!
    def receive: Receive = {
        case "revert" => unbecome
    }
!/sc!

1.9 PartialFunction Chaining            *akka-actor-partialfunc-chaining* {{{2
------------------------------------------------------------------------------

Here we can use the {orElse} method on {PartialFunction} to chain things
together and allow for some extensibility:
!sc!
    abstract class GenericActor extends Actor {
     
      // to be defined in subclassing actor
      def specificMessageHandler: PartialFunction[Any, Unit]
     
      // generic message handler
      def genericMessageHandler = {
          ... // generic message handler
      }
     
      def receive = specificMessageHandler orElse genericMessageHandler
    }
    
    class SpecificActor extends GenericActor {
      def specificMessageHandler = {
        ... // specific message handler
      }
    }
!/sc!

1.10 Actor Registry                                 *akka-actor-registry* {{{2
------------------------------------------------------------------------------

Every time an {Actor} is started it is added to the {ActorRegistry} and every
time it's stopped, it gets removed.  The registered {Actor}s (by {ActorRef})
are indexed by two identifiers: the {ActorRef}s {UUID} and the {ActorRef}s
specific {Id}.

An {ActorRef}'s {UUID} never changes, but its {Id} is can be modified by
anyone at any time.  The problem with that is that the mapping in the
{ActorRegistry} has a copy of the {Id} in a key field so if it changes, you're
going to be screwed.

If you want to change the {Id}, you're going to have to {unregister} the
{ActorRef} and then {register} it again.
!sc!
  scala> class MyActor extends Actor {
       |   def receive = {
       |     case "hi" =>
       |   }
       | } 
  defined class MyActor
  
  scala> def mkActor(id: String) = actorOf(new MyActor { self.id = id })
  mkActor: (id: String)akka.actor.ActorRef
  
  scala> var blues = mkActor("blue1") :: mkActor("blue2") ::
       |             mkActor("blue3") :: mkActor("blue4") :: Nil
  blues: List[akka.actor.ActorRef] = List(
    Actor[blue1:074eda70-43fd-11e0-a132-005056c00008],
    Actor[blue2:07520ec0-43fd-11e0-a132-005056c00008],
    Actor[blue3:07520ec1-43fd-11e0-a132-005056c00008],
    Actor[blue4:07520ec2-43fd-11e0-a132-005056c00008])
  
  scala> var reds = mkActor("red1") :: mkActor("red2") ::
                    mkActor("red3") :: mkActor("red4") :: Nil     
  reds: List[akka.actor.ActorRef] = List(
    Actor[red1:15eb1670-43fd-11e0-a132-005056c00008],
    Actor[red2:15eb1671-43fd-11e0-a132-005056c00008],
    Actor[red3:15eb1672-43fd-11e0-a132-005056c00008],
    Actor[red4:15eb1673-43fd-11e0-a132-005056c00008])
  
  scala> blues.foreach(_.start)
  
  scala> reds.foreach(_.start) 
  
  scala> Actor.registry.actors.foreach((x) => println(x.uuid + ": " + x.id))
  15eb1670-43fd-11e0-a132-005056c00008: red1
  07520ec2-43fd-11e0-a132-005056c00008: blue4
  15eb1673-43fd-11e0-a132-005056c00008: red4
  074eda70-43fd-11e0-a132-005056c00008: blue1
  15eb1671-43fd-11e0-a132-005056c00008: red2
  15eb1672-43fd-11e0-a132-005056c00008: red3
  07520ec0-43fd-11e0-a132-005056c00008: blue2
  07520ec1-43fd-11e0-a132-005056c00008: blue3

  // I'm not really sure the 'find' function is of all that much use
  scala> Actor.registry.find({
       |   case a: ActorRef if a.id endsWith "1" => a
       | })
  res6: Option[akka.actor.ActorRef] =
    Some(Actor[red1:15eb1670-43fd-11e0-a132-005056c00008])

  // When we can just do this instead:
  scala> Actor.registry.actors.find((x) => x.id endsWith "1")
  res7: Option[akka.actor.ActorRef] =
    Some(Actor[red1:15eb1670-43fd-11e0-a132-005056c00008])
!/sc!
You can also register different types and pull them out based on their
concrete type:
!sc!
  scala> actorOf(new NewActorType { self.id = "newType1" }).start
  res9: akka.actor.ActorRef =
    Actor[newType1:f6c57040-4403-11e0-a132-005056c00008]
  
  scala> actorOf(new NewActorType { self.id = "newType2" }).start
  res10: akka.actor.ActorRef =
    Actor[newType2:f94934f0-4403-11e0-a132-005056c00008]
  
  scala> actorOf(new NewActorType { self.id = "newType3" }).start
  res11: akka.actor.ActorRef =
    Actor[newType3:fb2c25c0-4403-11e0-a132-005056c00008]
  
  scala> actorOf(new NewActorType { self.id = "newType4" }).start
  res12: akka.actor.ActorRef =
    Actor[newType4:fcdbd190-4403-11e0-a132-005056c00008]
  
  scala> Actor.registry.actors.foreach((x) => println(x.uuid + ": " + x.id))
  15eb1670-43fd-11e0-a132-005056c00008: red1
  07520ec2-43fd-11e0-a132-005056c00008: blue4
  fb2c25c0-4403-11e0-a132-005056c00008: newType3
  15eb1673-43fd-11e0-a132-005056c00008: red4
  074eda70-43fd-11e0-a132-005056c00008: blue1
  15eb1671-43fd-11e0-a132-005056c00008: red2
  fcdbd190-4403-11e0-a132-005056c00008: newType4
  f94934f0-4403-11e0-a132-005056c00008: newType2
  f6c57040-4403-11e0-a132-005056c00008: newType1
  15eb1672-43fd-11e0-a132-005056c00008: red3
  07520ec0-43fd-11e0-a132-005056c00008: blue2
  07520ec1-43fd-11e0-a132-005056c00008: blue3

  scala> Actor.registry.actorsFor[NewActorType]
  res14: Array[akka.actor.ActorRef] = Array(
    Actor[newType3:fb2c25c0-4403-11e0-a132-005056c00008],
    Actor[newType4:fcdbd190-4403-11e0-a132-005056c00008],
    Actor[newType2:f94934f0-4403-11e0-a132-005056c00008],
    Actor[newType1:f6c57040-4403-11e0-a132-005056c00008])
!/sc!
And if you give a bunch of {Actor}s the same {Id} then you can pull them all
out in a single {Array}:
!sc!
  scala> actorOf(new NewActorType { self.id = "sameId" }).start             
  res15: akka.actor.ActorRef =
    Actor[sameId:6777d760-4404-11e0-a132-005056c00008]
  
  scala> actorOf(new NewActorType { self.id = "sameId" }).start
  res16: akka.actor.ActorRef =
    Actor[sameId:67d75c80-4404-11e0-a132-005056c00008]
  
  scala> actorOf(new NewActorType { self.id = "sameId" }).start
  res17: akka.actor.ActorRef =
    Actor[sameId:680b8be0-4404-11e0-a132-005056c00008]
  
  scala> actorOf(new NewActorType { self.id = "sameId" }).start
  res18: akka.actor.ActorRef =
    Actor[sameId:6852ce10-4404-11e0-a132-005056c00008]
  
  scala> Actor.registry.actorsFor("sameId")
  res19: Array[akka.actor.ActorRef] = Array(
    Actor[sameId:6777d760-4404-11e0-a132-005056c00008],
    Actor[sameId:67d75c80-4404-11e0-a132-005056c00008],
    Actor[sameId:680b8be0-4404-11e0-a132-005056c00008],
    Actor[sameId:6852ce10-4404-11e0-a132-005056c00008])
!/sc!

1.11 Remote Actors                                    *akka-actor-remote* {{{2
------------------------------------------------------------------------------

{Actor}s can be launched, connected-to, and managed remotely, and the work
involved in doing all of this isn't much more complicated than doing the same
locally.

Remote {Actor}s are built on an efficient and scalable network I/O
implementation based on JBoss Netty and Google Protocol Buffers.


1.11.1 Starting Up Remote                    *akka-actor-remote-startup* {{{3
------------------------------------------------------------------------------

The {remote} subsystem is accessible via the |akka-actor-object|.  It's pretty
simple to start it up and shut it down:
!sc!
  scala> Actor.remote.start("localhost", 20000)
  08:50:30.730 [main] DEBUG akka.remote.netty.NettyRemoteSupport -
    Starting up remote server on localhost:20000
  res3: akka.remoteinterface.RemoteServerModule =
    akka.remote.netty.NettyRemoteSupport@576f8789

  scala> Actor.remote.shutdown                 
  08:51:13.821 [main] DEBUG akka.remote.netty.NettyRemoteSupport -
    Shutting down remote server on localhost:20000
!/sc!
That's the programatic way to do it but you can also configure it via the
configuration file ({akka.conf}):
>
 akka {
   remote {

     # generate your own with '$AKKA_HOME/scripts/generate_secure_cookie.sh'
     # or using 'Crypt.generateSecureCookie'
     secure-cookie = "050E0A0D0D06010A00000900040D060F0C09060B"

     # Options: "zlib" (lzf to come), leave out for no compression
     compression-scheme = "zlib"

     # Options: 0-9 (1 being fastest and 9 being the most compressed), default
     # is 6
     zlib-compression-level = 6

     server {
       # The hostname or IP that clients should connect to
       hostname = "localhost"

       # The port clients should connect to. Default is 2552 (AKKA)
       port = 2552

       # Increase this if you want to be able to send messages with large
       # payloads
       message-frame-size = 1048576
       connection-timeout = 1

       # Should the remote server require that it peers share the same
       # secure-cookie (defined in the 'remote' section)?
       require-cookie = on

       # Enable untrusted mode for full security of server managed actors,
       # allows untrusted clients to connect.
       untrusted-mode = off

       # Sets the size of the connection backlog
       backlog = 4096
     }
   }
 }
<
Given the above configuration, then you can forego the programatic
configuration and just let it default construct:
!sc!
  scala> Actor.remote.start                    
  08:57:02.175 [main] DEBUG akka.remote.netty.NettyRemoteSupport -
    Starting up remote server on localhost:2552
  res5: akka.remoteinterface.RemoteServerModule =
    akka.remote.netty.NettyRemoteSupport@576f8789
  
  scala> Actor.remote.shutdown
  08:57:07.460 [main] DEBUG akka.remote.netty.NettyRemoteSupport -
    Shutting down remote server on localhost:2552
!/sc!

1.11.2 Registering Actors                    *akka-actor-remote-register* {{{3
------------------------------------------------------------------------------

If your code is taking the role of the "server" then it's reasonable to
{register} your {Actor}s in the remote node directly after construction, like
this:
!sc!
  scala> Actor.remote.start   

  scala> class Ponger extends Actor {
       |   def receive = { 
       |     case "Ping" =>
       |       println("Received a Ping")
       |       self.reply("Pong") 
       |   }
       | }
  defined class Ponger
  
  scala> Actor.remote.register("pong-service", actorOf[Ponger])
  
  scala> var ponger = Actor.remote.actorFor("pong-service", "localhost", 2552)
  
  scala> ponger !! "Ping"
  Received a Ping
  res9: Option[Any] = Some(Pong)
  
  scala> Actor.remote.shutdown
!/sc!
You can also register {Actor}s by their {UUID} instead of by their {Id} or
{Handle} directly by prefixing the registration / deregistration with the
{uuid} protocol:
!sc!
    remote.register("uuid:" + actor.uuid, actor)
    remote.unregister("uuid:" + actor.uuid)
!/sc!

1.11.3 Invoking Actors Remotely                *akka-actor-remote-invoke* {{{3
------------------------------------------------------------------------------

If you're the "client" then it might be reasonable to request that an {Actor}
be launched on the remote node:
!sc!
  scala> var ponger = remote.actorOf[Ponger]("localhost", 2552).start
  ponger: akka.actor.ActorRef =
    Actor[Ponger:e89d51d0-440e-11e0-9725-005056c00008]
  
  scala> ponger !! "Ping"
  Received a Ping
  res19: Option[Any] = Some(Pong)
!/sc!
You can also use the {spawnRemote} and {spawnLinkRemote} functions as well to
launch {Actor}s remotely:
!sc!
  scala> val a = actorOf(new Actor {
       |    // spawnLinkRemote is another option, which has the same effect
       |    // for this particular use case, but obviously linking changes
       |    // in the more general sense.
       |    val ponger = self.spawnRemote[Ponger]("localhost", 2552, 600)
       |
       |    def receive = {
       |      case "Ping" =>
       |        println("Calling the remote Ponger")
       |        self.reply(ponger !! "Ping")
       |    }
       |  }).start

  scala> a !! "Ping"
  Calling the remote Ponger
  Received a Ping
  res1: Option[Any] = Some(Some(Pong))
!/sc!

1.11.4 Connection Fault Tolerance          *akka-actor-remote-resilience* {{{3
------------------------------------------------------------------------------

Remote clients automatically perform reconnection upon failure.  You can
configure it explicitly 
>
 akka {
   remote {
     client {
       reconnect-delay = 5
       read-timeout = 10
       message-frame-size = 1048576

       # Maximum time window that a client should try to reconnect for
       reconnection-time-window = 600
     }
   }
 }
<
Eventually the reconnect attempt may timeout, at which point the next usage
will yield a {RemoteClientException}.  Now, I'm sure it's a pain in the ass to
have to recognize this "at the right time", but assuming you go through that
pain, the exception carries the reference to the {RemoteClient} so you could
try to do an explicit connect if you want.

It's probably easier to register a listener that will list for the
{RemoteClientStopped} event instead of trying to deal with the exception
"wherever it may occur".


1.11.5 Remote Security                       *akka-actor-remote-security* {{{3
------------------------------------------------------------------------------

It's possible to run the server in "untrusted mode".  Essentially, this stops
the client from doing anything related to the {LifeCycle} of the {Actor}s
running in the remote node.  This includes:

- Sending {LifeCycle} control messages
  - HotSwap
  - RevertHotSwap
  - Restart
  - Exit
  - Link
  - Unlink
  - UnlinkAndStop
  - ReceiveTimeout
- Invoking {LifeCycle} affecting commands
  - start
  - stop
  - link
  - unlink
  - spawnLink
  - etc...

You turn on "untrusted mode" with a configuration parameter:
>
 akka {
   remote {
     server {
       # Enable untrusted mode for full security of server managed actors,
       # allows untrusted clients to connect.
       untrusted-mode = on
     }
   }
 }
<
Akka also has a "secure cookie" mechanism similar to that used in {Erlang}.
Assuming all your nodes are configured appropriately to use the secure cookie,
and you have configured the node to require the cookie:
>
 akka {
   remote {
     # generate your own with '$AKKA_HOME/scripts/generate_secure_cookie.sh'
     # or using 'Crypt.generateSecureCookie'
     secure-cookie = "050E0A0D0D06010A00000900040D060F0C09060B"

     server {
       # Should the remote server require that it peers share the same
       # secure-cookie (defined in the 'remote' section)?
       require-cookie = on
     }
   }
 }
<
When connecting, a client will send its cookie across SSL and, assuming it
matches the server's version, the client will be granted full access and, if
not you will get a {java.lang.SecurityException}.

1.11.6 Session Based Servers                 *akka-actor-remote-sessions* {{{3
------------------------------------------------------------------------------

You can specify that Server-side {Actor}s be created on a "session" basis,
such that every new client {Actor} that connects would get a new {Actor}
instance for that particular registration.  The {Actor}s are stopped
automatically when the client disconnects.

A session-based {Actor} would be useful if we need to keep some per-session
state such as a username or want to do a per-client amount of cleanup by
overriding the {postStop} method on the server-side {Actor}.

Getting a session-based {Actor} up and running is dead simple - just use
{registerPerSession} instead of {register}:
!sc!
  class Ponger extends Actor {
    def receive = {
      case "Ping" => self.reply("Pong")
    }
  }

  remote.start
  remote.registerPerSession("pong-service", actorOf[Ponger])
!/sc!
According to the ScalaDoc for the {registerPerSession} method, we must
{unregister} the actor by this {Id} on our own.


1.11.7 Event Listening                         *akka-actor-remote-events* {{{3
------------------------------------------------------------------------------

The remote node will publish client-related events to registered listeners:
!sc!
  val listener = actorOf(new Actor {
    def receive = {
      case RemoteClientError(cause, client, address) => ...
      case RemoteClientDisconnected(client, address) => ...
      case RemoteClientConnected(client, address)    => ...
      case RemoteClientStarted(client, address)      => ...
      case RemoteClientShutdown(client, address)     => ...
      case RemoteClientWriteFailed(request, cause, client, address) => ...
      case _ => //ignore other
    }
  }).start
  remote.addListener(listener)
  ...
  remote.removeListener(listener)
!/sc!
And the same types of events are availble for server-related objects:
!sc!
  val listener = actorOf(new Actor {
    def receive = {
      case RemoteServerStarted(server)                           => ...
      case RemoteServerShutdown(server)                          => ...
      case RemoteServerError(cause, server)                      => ...
      case RemoteServerClientConnected(server, clientAddress)    => ...
      case RemoteServerClientDisconnected(server, clientAddress) => ...
      case RemoteServerClientClosed(server, clientAddress)       => ...
      case RemoteServerWriteFailed(request, casue, server, clientAddress) => ...
      case _ => //ignore other
    }
  }).start
  remote.addListener(listener)
  ...
  remote.removeListener(listener)
!/sc!

1.11.8 Messge Serialization             *akka-actor-remote-serialization* {{{3
------------------------------------------------------------------------------

	*Todo	needs to be investigated


==============================================================================
2. Actor Supervision                                   *akka-supervision* {{{1
------------------------------------------------------------------------------

==============================================================================
3. Actor Routing                                           *akka-routing* {{{1
------------------------------------------------------------------------------

Routing is tightly coupled with |akka-actors| but are technically in their own
distinct realm so they can be studied separately.

The Routing framework gives us a mechanism by which we can route work to
{Actor}s in different ways in order to help us load balance them and/or
provide another level of fault tolerance by sending the same message to
multiple {Actor}s in order to increase the liklihood of a response message in
the face of "interesting" failures.


3.1 Simple Dispatching                         *akka-routing-dispatching* {{{2
------------------------------------------------------------------------------

There are a couple of ways to get a dispatcher up and running.  The first way
is to use the factory method located in the {akka.routing.Routing} companion
object:
!sc!
    import akka.actor.Actor._
    import akka.actor.Actor
    import akka.routing.Routing._
     
    case object Ping
    case object Pong
     
    val pinger = actorOf(new Actor {
        def receive = { case msg => println("Pinger: " + msg) }
      }).start
    
    val ponger = actorOf(new Actor {
        def receive = { case msg => println("Ponger: " + msg) }
      }).start
     
    val d = dispatcherActor {
      case Ping => pinger
      case Pong => ponger
    }
 
  scala> d ! Ping
  Pinger: Ping

  scala> d ! Pong
  Ponger: Pong
!/sc!
As can be seen, the messages only get routed if they go through the
{dispatcher}, obviously.  I suppose if we wanted, we could send to the
{dispatcher} and also send to the {Actor}s directly however we saw fit.

Another way to do the same thing, but provides more programmatic flexibility
is to mix in the {Dispatcher} trait and define the {routes} method:
!sc!
    import akka.actor.Actor
    import akka.actor.Actor._
    import akka.routing.Dispatcher
     
    case object Ping
    case object Pong
     
    class MyDispatcher extends Actor with Dispatcher {
      val pinger = actorOf(new Actor {
          def receive = { case msg => println("Pinger: " + msg) }
        }).start
      val ponger = actorOf(new Actor {
          def receive = { case msg => println("Ponger: " + msg) }
        }).start
      def routes = {
        case Ping => pinger
        case Pong => ponger
      }
    }
     
    val d = actorOf[MyDispatcher].start
 
  scala> d ! Ping
  Pinger: Ping

  scala> d ! Pong
  Ponger: Pong
!/sc!

3.2 Simple Load Balancing                      *akka-routing-loadbalance* {{{2
------------------------------------------------------------------------------

Another way to route information is using a {LoadBalancer}.  Again, there are
a couple of ways to do this, with the first being more ad-hoc than the second:
!sc!
    import akka.actor.Actor._
    import akka.actor.Actor
    import akka.routing.Routing._
    import akka.routing.CyclicIterator
     
    case object Ping
    case object Pong
     
    val pinger = actorOf(new Actor {
        def receive = { case msg => println("Pinger: " + msg) }
      }).start
    val ponger = actorOf(new Actor {
        def receive = { case msg => println("Ponger: " + msg) }
      }).start
     
    val d = loadBalancerActor(new CyclicIterator(List(pinger, ponger)))

  scala> d ! Ping
  Pinger: Ping

  scala> d ! Ping
  Ponger: Ping

  scala> d ! Pong
  Pinger: Pong

  scala> d ! Pong
  Ponger: Pong
!/sc!
Above we can see a simple "round robin" load balancer such that we keep moving
around the {List} routing to the next candidate regardless of what's happening
in the system.
!sc!
    import akka.actor._
    import akka.actor.Actor._
    import akka.routing.{LoadBalancer, CyclicIterator}
     
    case object Ping
    case object Pong
     
    class MyLoadBalancer extends Actor with LoadBalancer {
      val pinger = actorOf(new Actor {
        def receive = { case msg => println("Pinger: " + msg) }
      }).start
      val ponger = actorOf(new Actor {
        def receive = { case msg => println("Ponger: " + msg) }
      }).start
     
      val seq = new CyclicIterator[ActorRef](List(pinger, ponger))
    }
 
    val d = actorOf[MyLoadBalancer].start

  scala> d ! Ping
  Pinger: Ping

  scala> d ! Ping
  Ponger: Ping

  scala> d ! Pong
  Pinger: Pong

  scala> d ! Pong
  Ponger: Pong
!/sc!
Beyond the {CyclicIterator}, we can use a more intelligent iterator that
routes based on the size of the {Mailbox} in the {ActorRef}.  Creating one of
these is as simple as the above:
!sc!
    import akka.routing.SmallestMailboxFirstIterator

    val d = loadBalancerActor(new SmallestMailboxFirstIterator(
        List(pinger, ponger)))
!/sc!

3.3 Actor Pools                                      *akka-routing-pools* {{{2
------------------------------------------------------------------------------

{Actor} Pools are more complex than the simple mechanisms described above, but
in truth, they're probably the only serious method you'd ever use in a real
application.

A Pool provides the ability to dynamically shrink and grow the number of
available {Actor}s based on {capacity} and {pressure}, as well as providing a
number of different parameters to enhance the routing strategy.

	*Error	it turns out these aren't in 1.0 yet.  I can see them in the git
	*Error	repository but they're not in the distribution yet. I'm going to
	*Error	hold off on these for the moment.

Modelines: {{{1
vim:tw=78:ts=4:ft=help:fdm=marker:fdl=0
